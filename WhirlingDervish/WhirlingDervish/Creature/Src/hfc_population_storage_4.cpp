/***********************************   Art Covert -- 9/2004   HFC population storage class for WhirlingDervish ***********************************/#define DBL_MIN   2.2250738585072014e-308#define DBL_MAX   2.2250738585072014e+308#include <algorithm>#include <cmath>#include <iostream>#include <iomanip>#include <sstream>#include <iomanip>#include "random.h"#include "environment_data.h"#include "creature_info.h"#include "hfc_population_storage_4.h"using namespace std;hfcPopulationStorage4::hfcPopulationStorage4(void){  return;}hfcPopulationStorage4::~hfcPopulationStorage4(void) {  if(out && out.is_open())  {    out.close();  }  return;}bool hfcPopulationStorage4::InitializeLocal(unsigned int, EnvironmentData &ed){  out.open("suppopulation_fitness.txt", ios::out);  if(!out) { return false; }  // Each level gets a buffer whose size is equal to the population size  vector<CreatureInfo*> temp;  temp.reserve(d_populationSize);  for(unsigned int i = 0; i < d_numberOfLevels; i++){    d_buffer.push_back(temp);  }  // Create creatures that could fill the buffers  // Three because we know the base reserves 2 times, and we are adding a 3rd  extraCritters.reserve(d_populationSize * d_numberOfLevels * 3);  CreatureInfo *ci;  for(unsigned int i=0; i<d_populationSize * d_numberOfLevels; i++)  {    ci = new CreatureInfo();    if(ci == NULL) {      Clear(ed);      return false;    }    ci->Clean(ed);    ci->ParentId() = 0;    ci->Fitness() = 0.0;    ci->Id() = d_currentId;    d_currentId++;    extraCritters.push_back(ci);  }  for(unsigned int i = 0; i < d_levels.size(); i ++){     d_levelSize.push_back(d_levels.at(i).size());  }  return true;}void hfcPopulationStorage4::ClearLocal(EnvironmentData &ed){  cerr << "ClearLocal_top" << endl;  // Clear out the buffers and put anything they find on the extra list  vector<CreatureInfo *>::iterator i;  for(unsigned g=0; g < d_buffer.size(); g++){    for(i=d_buffer.at(g).begin(); i != d_buffer.at(g).end(); ++i) {      if(*i != NULL) {	(*i)->Clean(ed);	extraCritters.push_back(*i);	*i = NULL;      }    }  }  if(out && out.is_open())  {    out.close();  }  cerr << "ClearLocal_bottom" << endl;  return;}void hfcPopulationStorage4::InitializeADT(void){  ADTs.at(0) = (double)DBL_MIN;  ADTs.at(1) = (double)DBL_MAX;  ADTs.at(2) = (double)DBL_MAX;  ADTs.at(3) = (double)DBL_MAX;  return;}void hfcPopulationStorage4::DetermineADTValues(vector<double> &fitnessSpread,					      double fMax, double fAvg,					      double fStdDev){  //from Hu et al,   ADTs.at(0) = DBL_MIN;  ADTs.at(1) = fAvg;  ADTs.at(3) = fMax - fStdDev;  ADTs.at(2) = ((ADTs.at(3) - fAvg)/2.0) + fAvg;  return;}void hfcPopulationStorage4::PreprocessAllCreatures(EnvironmentData &ed){  vector<unsigned int> promoted;  vector<unsigned int> demoted;  unsigned int allIndex = 0;  //clearSubpopulations(ed);  cleanBuffers(ed);  if(d_Generation % d_recomputeADTFrequency == 0){    d_levelSize.clear();    for(unsigned int i = 0; i < d_levels.size(); i ++){      d_levelSize.push_back(d_populationSize);    }  }  unsigned a = 0, b = 0, c = 0;  // Remove promoted creatures from all creatures and put them in the buffer  for(unsigned int i=0; i<d_levels.size() && allIndex<allCreatures.size(); i++)  {    for(unsigned int j=0;j < d_levelSize.at(i) && allIndex < allCreatures.size();j++)    {      CreatureInfo *ci = allCreatures.at(allIndex);      if(ci == NULL) { continue; }      unsigned int ADTLevel = getSubPop(*ci);            // i should be the level the parent was in      if(ADTLevel > i)      {	a++;	promoted.push_back(allIndex);      }      else if(ADTLevel < i)      {	b++;	demoted.push_back(allIndex);      }      else{	c++;	d_levels.at(i).push_back(allCreatures.at(allIndex));      }      allIndex++;    }  }  cerr << "a = " << a << endl       << "b = " << b << endl       << "c = " << c << endl;    // Put promoted creatures into the buffer or clear it and put it on the  // extra critters if the buffer is full  // Work from highest ids to smallest  sort(promoted.begin(), promoted.end());  for(int i=(int)(promoted.size())-1; i>=0; i--)  {    // Clear and reassign pointer    CreatureInfo *ci = allCreatures.at(promoted.at(i));    // Not handling demotion?    unsigned int ADTLevel = getSubPop(*ci);    if(d_buffer.at(ADTLevel).size() < d_populationSize)    {      d_buffer.at(ADTLevel).push_back(ci);    }    else    {      // Buffer was full      ci->Clean(ed);      extraCritters.push_back(ci);    }  }  for(unsigned int i = 0; i < demoted.size(); i++){    CreatureInfo *ci = allCreatures.at(demoted.at(i));    if(ci != NULL){      ci->Clean(ed);      extraCritters.push_back(ci);    }  }  useBuffers(ed);  allCreatures.clear();#if 1  cout << "Subpopulation sizes" << endl;  for(unsigned int i=1; i<=ADTs.size(); i++)  {    cout << "Level " << i << ": " << d_levels.at(i-1).size() << endl;  }#endif  return;}void hfcPopulationStorage4::cleanBuffers(EnvironmentData &ed){  vector<CreatureInfo*>::iterator critter;  for(unsigned int i = 0; i < d_buffer.size(); i++){    critter = d_buffer.at(i).begin();        while(critter != d_buffer.at(i).end()){      if((*critter)->Fitness() < ADTs.size()){	critter++;      }      else{	if((*critter) == NULL) { continue; }	else { 	  (*critter)->Clean(ed);	  extraCritters.push_back((*critter));	}	d_buffer.at(i).erase(critter);      }    }  }}void hfcPopulationStorage4::useBuffers(EnvironmentData &ed){  for(unsigned int i = 0; i < d_levels.size(); i++){    while((d_levels.at(i).size() < d_populationSize)	  &&(d_buffer.at(i).size() > 0)){      d_levels.at(i).push_back(d_buffer.at(i).back());      d_buffer.at(i).pop_back();    }  }}void hfcPopulationStorage4::HandleOverflow(vector<unsigned int> &idsNotAdded,					   EnvironmentData &ed){  // Could have overflow from demotion  // What to do with the overflow???  This just deletes it, but could also  // add it to buffers.  Are buffers just for promotions?  // Work from highest ids to smallest  sort(idsNotAdded.begin(), idsNotAdded.end());  for(int i=(int)(idsNotAdded.size())-1; i>=0; i--)  {    // Clear and reassign pointer    CreatureInfo *ci = allCreatures.at(idsNotAdded.at(i));    ci->Clean(ed);    extraCritters.push_back(ci);    // Remove pointer from allCreatures    allCreatures.at(idsNotAdded.at(i)) = allCreatures.back();    allCreatures.pop_back();  }  // Now fill in the empty slots in the levels with stuff from the buffer  for(unsigned int i=0; i<d_levels.size(); i++)  {    for(unsigned int j=d_levels.size();j < d_populationSize && !(d_buffer.at(i).empty());j++)    {      // Take the first creature in the vector      CreatureInfo *ci = d_buffer.at(i).front();      d_buffer.at(i).erase(d_buffer.at(i).begin());      d_levels.at(i).push_back(ci);      allCreatures.push_back(ci);    }  }#if 1  cout << "Subpopulation sizes" << endl;  for(unsigned int i=1; i<=d_levels.size(); i++)  {    cout << "Level  " << i << ": " << d_levels.at(i-1).size() << endl;  }  for(unsigned int i=1; i<=d_buffer.size(); i++)  {    cout << "Buffer " << i << ": " << d_buffer.at(i-1).size() << endl;  }  out << "Addaptive Thresholds set:";  out << showpoint << fixed << setprecision(6);  for(unsigned int i=0; i<ADTs.size(); i++)  {    out << " " << setw(10) << ADTs.at(i);  }  out << endl;  vector<double> tempAvg;  for(unsigned int i=1; i<=d_levels.size(); i++)  {    cout << "Fitness info (" << i << "): ";    getFitnessSpread(d_levels.at(i-1), tempAvg);    sort(tempAvg.begin(), tempAvg.end());    out << d_levels.at(i-1).size() << "(" << average(tempAvg) << ", "	<< tempAvg.front() << ", " << tempAvg.back() << ") ";    out << endl;    tempAvg.clear();  }#endif  return;}